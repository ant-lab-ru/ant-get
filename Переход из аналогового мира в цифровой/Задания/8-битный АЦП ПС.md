---
тема: Переход из аналогового мира в цифровой
автор: Иван Юрьевич Потылицын
дата: 2025-10-18
задание: false
---

## Расшифровка названия задания

8-битный [[аналого-цифровой преобразователь]] [[АЦП последовательного счёта|последовательного счёта]]

## Результат

- [ ] При помощи объекта класса можно измерить напряжение на выходе [[потенциометр|потенциометра]] **U** в блоке **8-bit ADC** платы [[Печатная плата get-adc|get-adc]]
- [ ] Основной охранник модуля с описанием класса в бесконечном цикле:
    - [ ] Измеряет напряжение на выходе потенциометра
    - [ ] Печатает напряжение в терминал
    - [ ] Делает паузу на 1 секунду

> [!EXAMPLE] Пример
> 
> **Изменение напряжения на выходе потенциометра**
> 
> Гифка, как крутить потенциометр
> 
> **Напряжение, измеренное объектом класса R2R_DAC**
> 
> Скриншот измерения напряжения
> 
> **Объективная проверка R2R_DAC**
> 
> Фото напряжения на мультиметре

## Подготовка

1. Создайте в вашем репозитории **get** папку **get-adc**
2. В папке **get-dac** создайте файл **r2r_adc.py**
3. В созданном файле описывайте класс для реализации 8-битного [[АЦП последовательного счёта|АЦП ПП]]

## Инструкция

1. Импортируйте модули работы с GPIO и временем
2. Объявите класс **R2R_ADC** и реализуйте его обязательный конструктор со значениями аргументов по умолчанию

```
class R2R_ADC:
    def __init__(self, dynamic_range, compare_time = 0.01, verbose = False):
        self.dynamic_range = dynamic_range
        self.verbose = verbose
        self.compare_time = compare_time
        
        self.bits_gpio = [26, 20, 19, 16, 13, 12, 25, 11]
        self.comp_gpio = 21

        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.bits_gpio, GPIO.OUT, initial = 0)
        GPIO.setup(self.comp_gpio, GPIO.IN)
```

> [!HINT] Совет
> 
> Используйте возможность Python задавать аргументы функций по умолчанию.
> 
> В случае с классом **R2R_ADC** обязательным аргументом стоит оставить динамический диапазон, потому что он будет разным на каждой малинке.
> 
> По умолчанию можно задать время для работы компаратора и явный вывод отладочной информации при оцифровке напряжения.

> [!HINT] Ещё совет
> 
> Номера GPIO пинов ЦАП и номер GPIO пина, подключённого к выходу [[Компаратор|компаратора]], меняться не будут, поэтому их можно не передавать аргументами, а задать в конструкторе.

3. Дополните класс «деструктором», который выставляет 0 на выход ЦАП и очищает настройки GPIO
4. Реализуйте метод **number_to_dac(self, number)**, который будет подавать число **number** на вход ЦАП

> [!HINT] Совет
> 
> Реализацию подачи числа на параллельный вход ЦАП стоит подсмотреть в задании [[Двоичный счётчик]].

5. Реализуйте метод **sequential_counting_adc(self):**
    1. Последовательно подавайте на вход [[Цифро-аналоговый преобразователь|ЦАП]] целые числа до тех пор, пока напряжение на выходе [[Цифро-аналоговый преобразователь|ЦАП]] не превысит входное напряжение [[Аналого-цифровой преобразователь|АЦП]]
    2. После подачи каждого числа делайте паузу для того, чтобы [[компаратор]] успел сравнить два входных напряжения и установить соответствующее напряжение на выход
    3. Соотношение напряжений на входе АЦП и на выходе ЦАП определяйте, читая GPIO-пин, подключённый к выходу компаратора
    4. При превышении напряжения на выходе ЦАП входного напряжения АЦП возвращайте целое число, которое было подано на ЦАП последним
    5. В случае, если напряжение на выходе ЦАП так и не превысило напряжение на входе АЦП, возвращайте максимальное число, которое можно подать на ЦАП

> [!EXAMPLE] Пример
> 
> **Входы компаратора при работе метода sequential_counting_adc()**
> 
> Фото подключения осциллографа ко входам компаратора
> 
> Скриншот осциллографа с работой sequential_counting_adc()
> 
> **Выход компаратора при работе метода sequential_counting_adc()**
> 
> Фото подключения осциллографа к выходам ЦАП и компаратора
> 
> Скриншот осциллографа с работой sequential_counting_adc()

6. Реализуйте метод **get_sc_voltage(self)**, который возвращает измеренное напряжение в Вольтах на основе [[Разрядность цифрового сигнала|разрядности]] и динамического диапазона ЦАП
7. Реализуйте [[основной охранник]]:
    1. В блоке **try:**
        1. Создайте объект класса **R2R_ADC**, передав ему динамический диапазон вашего ЦАП, который нужно будет предварительно измерить мультиметром
        2. В бесконечном цикле делайте три действия:
            1. Читайте напряжение
            2. Печатайте его в терминал
            3. Ждите 1 секунду, чтобы перегружать вывод
    2. В блоке **finally:**
        1. Вызовите «деструктор» объекта класса **R2R_ADC**

## Завершение задания

1. Добавьте модуль **r2r_adc.py** в репозиторий **get**, сделайте коммит и отправьте изменения на сервер
