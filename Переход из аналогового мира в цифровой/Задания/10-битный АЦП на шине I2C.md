---
тема: Переход из аналогового мира в цифровой
автор: Иван Юрьевич Потылицын
дата: 2025-10-20
задание: false
---

## Расшифровка названия задания

10-битный [[аналого-цифровой преобразователь]] на шине [[I2C-интерфейс|I2C]]

## Результат

- [ ] При помощи объекта класса можно измерить напряжение на входе микросхемы **MCP3021** в блоке **12-bit ADC** платы [[Печатная плата get-adc|get-adc]]
- [ ] Основной охранник модуля с описанием класса в бесконечном цикле:
    - [ ] Измеряет напряжение на входе АЦП
    - [ ] Печатает напряжение в терминал

> [!EXAMPLE] Пример
> 
> 
> **Напряжение, измеренное объектом класса MCP3021**
> 
> ![[10-bit-i2c-adc.png]]
> 
> **Объективная проверка MCP3021**
> 
> ![[10-bit-i2c-fluke.jpg]]
> 
>  ![[10-bit-i2c-dsl.bmp]]

> [!WARNING] Внимание
> 
> Для работы с **I2C** после каждой перезагрузки Raspberry Pi необходимо выполнить две команды в терминале:
> 
> - `raspi-gpio set 2 a0`
> - `raspi-gpio set 3 a0`
> 
> После выставления пинам **GPIO2** и **GPIO3** первой альтернативной функции (функции ножек линий **SDA** и **SCL** устройства **i2c1**) стоит убедиться в корректности выставления этих функций командой:
> 
> - `raspi-gpio get`
## Подготовка

1. В папке **get-adc** вашего репозитория **get** создайте файл **mcp3021_driver.py**
2. В созданном файле описывайте класс, представляющий собой драйвер для микросхемы **MCP3021** (10-битного АЦП на шине I2C)

## Инструкция

1. Импортируйте модуль работы шиной I2C
2. Объявите класс **MCP3021** и реализуйте его обязательный конструктор со значениями аргументов по умолчанию

```
import smbus

class MCP3021:
    def __init__(self, dynamic_range, verbose = False):
        self.bus = smbus.SMBus(1)
        self.dynamic_range = dynamic_range
        self.address = 0x4D
        self.verbose = verbose

```

3. Дополните класс «деструктором», который освобождает шину

```
def deinit(self):
    self.bus.close()
```

4. Реализуйте метод **get_number(self)**, который будет читать число из микросхемы **MCP3021**
    1. Прочитайте два байта из устройства по его адресу
    2. Выделите из прочитанного числа байт, который пришёл по шине вторым (lower)
    3. Выделите из прочитанного числа байт, который пришёл по шине первым (upper)
    4. Выделите из двух прочитанных байт число, переданное микросхемой в соответствии её документацией
    5. Распечатайте данные, байты и число, если задан явный вывод отладочной информации
    6. Верните прочитанное из микросхемы число

```
def get_number(self):
    data = self.bus.read_word_data(self.address, 0)
    lower_data_byte = data >> 8
    upper_data_byte = data & 0xFF
    number = (upper_data_byte << 6) | (lower_data_byte >> 2)
    if self.verbose:
        print(f"Принятые данные: {data}, Старший байт: {upper_data_byte:x}, Младший байт: {lower_data_byte:x}, Число: {number}")
    return number
```

> [!EXAMPLE] Пример
> **Выход компаратора и выход ЦАП при работе метода sequential_counting_adc()**
> 
> ![[10-bit-i2c-data.jpg]]
> 
> ![[10-bit-i2c-data-dsl.bmp]]

6. Реализуйте метод **get_voltage(self)**, который возвращает измеренное микросхемой **MCP3021** напряжение в Вольтах на основе [[Разрядность цифрового сигнала|разрядности]] и динамического диапазона АЦП
7. Реализуйте [[основной охранник]]:
    1. В блоке **try:**
        1. Создайте объект класса **MCP3021**, передав ему динамический диапазон вашего АЦП, который нужно аккуратно изменить мультиметром на контакте **PWR** блока **AUX** при включённой перемычке на 5V
        2. В бесконечном цикле делайте три действия:
            1. Читайте напряжение
            2. Печатайте его в терминал
            3. Ждите 1 с, чтобы не перегружать вывод терминала
    2. В блоке **finally:**
        1. Вызовите «деструктор» объекта класса **MCP3021**

## Завершение задания

1. Добавьте модуль **mcp3021_driver.py** в репозиторий **get**, сделайте коммит и отправьте изменения на сервер
